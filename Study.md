平日1日の目安：1つ以上テストを通す
休日は3つ以上

## Ch01

- f内のfは×
- sel[2] = 10 → sel[0] = 0
- セレクタ：1要素ずつ分岐する。 → k = log2 n
- 変数名にそれまでの評価分を与えるとわかりやすい。＠DMux8Way,Mux4Way16
- 評価の順番を考える。＠DMux8Way,Mux4Way16
- headerでlengthを定義していれば、配列は変数名で参照できる（当たり前）。

## Ch02

- 全加算：和の半加算を2回→sum、各半加算のcarryのOr→carry
- 分岐はMuxで表せる
- 反転はただのNot。でも反転するかどうかは入力で分岐してる。
- x[i..j]の指定のため、A.5.3のバスを用いる。接続ピンの任意の幅を接続に指定できる。
- 定数であるtrue,falseがバスで使えることも、A.5.3に書いてある

## Ch03

- まずは図をそのまま書き起こす
- フィードバックループ：出力をフィードバックとしても流す
- DMuxはinを伝えるかどうか選択に使える
- sel = 101110 → sel[0..2] = 110
- RAM8をベースとしたメモリの再帰構造
- load（書き込み）とフィードバックにより、out(t) = inまたはout(t - 1)の関係が成り立つ
- inまたはout(t - 1)は、DFFが時間遅延という性質を持つことでフィードバックできる

## Ch04

- Pseudo:「偽りの、にせの、まがいの」
- レジスタはDとAの2種類がただ1つずつのみ存在する（レジスタはDかAか指定するだけ）
- @xで、Aレジスタにxを格納する。その後でAに操作があれば、Aは後の操作後の値となる。@xはAへの1操作に過ぎない
- Mにより、Aレジスタで指定したアドレスのメモリワードの値を参照する
- AにR0やR1などを格納することで、RAM[0]やRAM[1]を参照できる。R0..R15は、仮想レジスタとしてRAM[0]..RAM[15]を参照する、定義済みシンボル
- SP,LCL,ARG,THISのシンボルは、それぞれRAMアドレスの0から4を参照する定義済みシンボル
- SCREENとKBDもI/Oポインタとして定義済みのシンボル
- comp領域によって計算を行う関数を指定している
- JGTやJMPはjump領域のニーモニック。それぞれのニーモニックごとに効果が異なる
- ラベルシンボルはユーザ定義
- Dが1以上のときにジャンプする
- ユーザ定義の変数シンボルを参照することで、値ごとの処理の重複を回避できる
- 16bit全部1にするためには、色を-1にする。各アドレスに16bitあることは、アセンブラシミュレータを見るとよくわかる

## Ch05

- Keyboardはloadなどなく、Keyboardのアドレスを指定すれば、loadに関係なく押されているキーコードを出力する
- まずは使うべき下位の回路を列挙。また命令をデコードする（仕様をまとめる）
- 1つ前の命令の結果をDやAとして受け取る。2つ以上前の値は、loadされないときはレジスタが保持している
- DRegisterとARegisterが用意されている
- 回路内で完結する値は出力とはならないが、求めるべき値である
- 中心となるCPUが、コンピュータアーキテクチャ（ハードウェア階層）の核となる